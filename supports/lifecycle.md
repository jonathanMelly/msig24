# üß¨ Cycle de vie d‚Äôune application

Une application passe par diff√©rentes √©tapes cl√©s qu‚Äôil s‚Äôagit d‚Äôappr√©hender.
Voici donc une liste simplifi√©e d‚Äô√©tapes √©l√©mentaires :

1. D√©finition des besoins
2. √âcriture
3. Tests
3. Release

## D√©finiton des besoins

C‚Äôest la construction d‚Äôun cahier des charges √©labor√© √† partir des besoins du client.

> Cela peut inclure un ou plusieurs prototypes afin de v√©rifier l‚Äôad√©quation avec les besoins du client :

![balancoire.jpg](balancoire.jpg)

## üñç √âcriture

C‚Äôest le moment o√π le programme est √©crit. Puisque le code √©volue beaucoup et que la collaboration
est n√©cessaire pour r√©aliser de grands projets, on appr√©cie d‚Äôutiliser un syst√®me de versioning, comme
[GIT](https://git-scm.com/).

### GIT

Git est un syst√®me de versioning populaire qui permet de sauvegarder "toute l‚Äôhistoire du code".
Autrement dit, `Git` est une sorte de `kopia` avec, en plus, un **suivi des modifications**.  
Ainsi √† chaque *snapshot* (point de sauvegarde) est associ√© un **message** plus ou moins d√©taill√© qui indique ce qui a √©t√© fait.
On peut donc **tracer** l'√©volution de documents num√©riques comme le montre l'image suivante :

![git.jpg](git.jpg)

Peut-√™tre le screenshot suivant sera plus parlant :

![zelda-save.png](zelda-save.png)

L'historique Git fonctionne de mani√®re similaire √† un syst√®me de sauvegarde automatique dans un jeu vid√©o. Lorsqu'on
travaille sur un projet, il est possible de cr√©er des "sauvegardes" √† des moments cl√©s, appel√©es **commits**. Chaque
commit enregistre l'√©tat exact des fichiers, `de la m√™me mani√®re qu'une sauvegarde dans un jeu capture la progression,
les objets et la position` ainsi qu'un message d√©crivant les modifications effectu√©es.

Git conserve une trace de toutes ces "sauvegardes", permettant ainsi de **revenir √† un √©tat ant√©rieur √† tout moment**,
comme
si `on rechargeait une ancienne partie`. Si une erreur survient ou si des modifications non d√©sir√©es ont √©t√© apport√©es,
il est possible de restaurer une version pr√©c√©dente sans perdre les autres progr√®s r√©alis√©s.

> Git fonctionne en conservant un historique du projet, avec des points de restauration, et offre la possibilit√© de
> naviguer entre diff√©rentes versions, un peu √† l'image des sauvegardes automatiques dans un jeu vid√©o.

Pour bien comprendre et int√©grer le concept, voici un exemple pratique pour *activer* un d√©p√¥t avec GIT partant du 
principe que l‚Äôoutil a d√©j√† √©t√© install√© (si ce n'est pas le cas se r√©f√©rer √† [GIT](https://git-scm.com/downloads)).

#### √âtape 1 : Cr√©er un d√©p√¥t local

1. **Cr√©er un r√©pertoire pour ton projet :**
   ```shell
   mkdir mon_projet
   cd mon_projet
   ```

2. **Initialiser un d√©p√¥t Git :**
   ```shell
   git init
   ```

#### √âtape 2 : Ajouter 1-2 fichiers et faire un commit

1. **Cr√©er un fichier dans ce r√©pertoire :**
   Par exemple, un fichier `README.md` :
   ```shell
   echo "# Mon Projet" > README.md
   git status
   ```

2. **Ajouter un deuxi√®me fichier :**
   ```shell
   echo "Ceci est un fichier texte." > fichier.txt
   git status
   ```

3. **Ajouter ces fichiers √† l'index Git :**
   ```shell
   git add README.md fichier.txt
   ```

4. **Faire un commit :**
   ```shell
   git commit -m "Ajout de README et fichier.txt"

   ```

> `git status` permet de voir l‚Äô√©tat des lieux des modifications en cours...

#### √âtape 3 : Ajouter un remote GitHub

1. **Cr√©er un d√©p√¥t vide sur GitHub** (sans README, .gitignore, etc.).

2. **Ajoute le d√©p√¥t GitHub en tant que remote :**
   Remplacer `URL_DU_DEPOT_GITHUB` par l'URL du d√©p√¥t GitHub (par ex :
   `https://github.com/ton-utilisateur/mon_projet.git`).
   ```shell
   git remote add origin https://github.com/ton-utilisateur/mon_projet.git
   ```

> [!TIP]  
> En cas d‚Äôerreur de manipulation, pour d√©truire une mauvaise remote la commande est `git remote remove origin`

#### √âtape 4 : Faire un push vers GitHub

1. **Pousse le commit vers GitHub :**
   ```shell
   git push -u origin main
   ```

   Cela envoie le commit local sur la branche `main` (ou `master`) de GitHub.

> [!WARNING]  
> Selon la version ou la configuration de GIT, le nom par d√©faut est `master` ou `main`. Github ayant choisi
> `main` par d√©faut, il faut potentiellement renommer `master` en `main` en cas d‚Äôerreur: `git branch -M main`

#### √âtape 5 : Tag

1. **Pour ajouter un tag (sorte de raccourci sur une version) :**
   ```shell
   git tag v1.0.0
   ```

> [!WARNING]  
> Pour que les tags soient synchronis√©s, il faut ajouter une option au `push`: `git push --tags`

#### √âtape 6 : Cloner le d√©p√¥t depuis GitHub

1. **Cloner le d√©p√¥t sur un autre r√©pertoire (ou une autre machine) :**
   ```shell
   git clone https://github.com/ton-utilisateur/mon_projet.git
   ```

Cela va cr√©er un r√©pertoire `mon_projet` dans le dossier actuel avec tout le contenu du d√©p√¥t GitHub.

#### R√©sum√© des commandes :

```shell
# Cr√©er un r√©pertoire et initialiser Git
mkdir mon_projet
cd mon_projet
git init

# Ajouter des fichiers et faire un commit
echo "# Mon Projet" > README.md

#V√©rifier l‚Äô√©tat
git status
echo "Ceci est un fichier texte." > fichier.txt
git add README.md fichier.txt

#V√©rifier l‚Äô√©tat
git status
git commit -m "Ajout de README et fichier.txt"

# Ajouter un remote et faire un push vers GitHub
git remote add origin https://github.com/ton-utilisateur/mon_projet.git
git push -u origin main

#Tag
git tag v1.0.0
git push --tags

# Cloner le d√©p√¥t depuis GitHub
git clone https://github.com/ton-utilisateur/mon_projet.git
```

#### Sch√©ma r√©capitulatif des op√©rations basiques

```mermaid
graph TD
subgraph Local [Actions Locales]
A[Cr√©er un r√©pertoire local]
B["Initialiser un d√©p√¥t Git
'git init .'
__"]
C[Cr√©er/Modifier des fichiers]
ADD[Ajouter des fichiers √† l'index
'git add ...'
__
]
COMMIT["Faire un commit local
'git commit -m 'feat(login): added help button''"
__
]
GHREPOEXIST{"D√©p√¥t d√©j√† cr√©√© sur github ?"}
G["Ajouter un remote vers GitHub
'git remote add origin $REPO_URL'
__"
]
PUSH["Pousser les commits vers GitHub
'git push' ou 'git push -u origin' (1√®re fois)"
__
]

I[Ajouter un tag pour une release
'git tag v1.0.0'
__
]
J[Pousser le tag vers GitHub
'git push tag v1.0.0'
]
end

subgraph Remote ["Actions Distantes (GitHub)"]
GH[Cr√©er un d√©p√¥t GitHub]

end

A --> B
B --> C
C --> ADD
ADD --> COMMIT
COMMIT --> GHREPOEXIST
COMMIT --> C
GHREPOEXIST-- oui --> PUSH
GHREPOEXIST-- non --> GH
GH --> G
G --> PUSH
PUSH --> C
PUSH --> I
I --> J
J --> C

style A fill: #045, stroke: #333, stroke-width: 4px
style GH fill: #055, stroke: #333, stroke-width: 4px
style Remote fill: #505, stroke: #333, stroke-width: 4px
style J fill: #505, stroke: #333, stroke-width: 4px
style PUSH fill: #505, stroke: #333, stroke-width: 4px

```

#### üìö Historique

Voici maintenant un exemple sur l‚Äôutilisation de l‚Äôhistorique.

Imaginons qu'un projet ait trois commits successifs avec les messages suivants :

1. **Commit 1** : "Ajout du fichier README.md"
2. **Commit 2** : "Ajout du fichier de configuration"
3. **Commit 3** : "Correction d'un bug dans le code"

##### √âtape 1 : V√©rifier l'historique des commits

Pour voir l'historique des commits, on peut utiliser la commande suivante :

```shell
git log
```

Cela affichera une liste des commits avec leur identifiant (hash), l'auteur, la date, et le message associ√©. Voici un
exemple de ce √† quoi cela peut ressembler :

```shell
commit 3f5e1bc... (HEAD -> master)
Author: Nom Auteur <email@example.com>
Date:   Lun Oct 9 14:30 2024

    Correction d'un bug dans le code

commit 6a1f2de...
Author: Nom Auteur <email@example.com>
Date:   Lun Oct 9 13:00 2024

    Ajout du fichier de configuration

commit f2c7a12...
Author: Nom Auteur <email@example.com>
Date:   Lun Oct 9 12:00 2024

    Ajout du fichier README.md
```

##### √âtape 2 : Naviguer vers un commit pr√©c√©dent

Si on souhaite revenir √† l'√©tat du projet tel qu'il √©tait apr√®s le **Commit 2**, on peut utiliser la commande suivante
pour "v√©rifier" cet ancien commit :

```shell
git switch --detach 6a1f2de
```

L√†, Git place le projet dans l'√©tat exact o√π il se trouvait apr√®s le commit "Ajout du fichier de configuration". √Ä ce
stade, l'historique reste intact, mais on est temporairement sur un commit sp√©cifique. On peut explorer ou v√©rifier les
fichiers comme ils √©taient √† ce moment-l√†.

##### √âtape 3 : Revenir √† l'√©tat actuel du projet

Pour revenir √† l'√©tat actuel du projet (la derni√®re version), il suffit de revenir √† la branche principale (g√©n√©ralement
appel√©e `master` ou `main`) :

```shell
git switch main
```

> [!TIP]  
> Historiquement la commande `checkout` √©tait utilis√©e mais d√©sormais `switch` et `restore` la remplacent...

Ainsi, on retourne √† l'√©tat le plus r√©cent du projet, tout en ayant navigu√© temporairement dans l'historique.

##### Conflits avec des modifications en cours

Si des modifications sont en cours, `git switch` pourrait √™tre probl√©matique et il existe une autre mani√®re
de faire.

Voici donc un exemple montrant comment utiliser **`git worktree`** pour acc√©der √† un tag (sachant que c‚Äôest la m√™me chose
pour un commit), travailler dessus, et ensuite effacer le worktree une fois le travail termin√©.

###### Contexte :

Vous devez acc√©der √† une ancienne version d'un projet, marqu√©e par un **tag** (par exemple `v1.0.0`), et une fois votre
travail ou inspection termin√©, vous souhaitez supprimer ce r√©pertoire temporaire.

::: tip
Au lieu d‚Äôun tag, un ID de commit va aussi
:::

###### √âtape 1 : Cr√©er un worktree bas√© sur un tag

Vous pouvez cr√©er un nouveau r√©pertoire de travail √† partir du tag `v1.0.0` en utilisant la commande suivante :

```shell
git worktree add ../v1.0.0-worktree v1.0.0
```

- **`../v1.0.0-worktree`** : Le chemin o√π le nouveau r√©pertoire sera cr√©√©.
- **`v1.0.0`** : Le tag que vous voulez consulter ou modifier.

###### √âtape 2 : Travailler sur la version tagu√©e

Ensuite, acc√©dez au nouveau r√©pertoire contenant la version du projet correspondant au tag `v1.0.0` :

```shell
cd ../v1.0.0-worktree
```

Vous pouvez maintenant examiner ou modifier les fichiers de cette version, sans perturber votre r√©pertoire de travail
principal.

###### √âtape 3 : Supprimer le worktree une fois termin√©

Une fois votre travail termin√© sur la version tagu√©e, vous pouvez revenir √† votre r√©pertoire principal et supprimer le
worktree pour √©viter d'encombrer votre disque :

1. Revenez √† votre r√©pertoire principal :
   ```shell
   cd ../mon_projet
   ```

2. Supprimez le worktree :
   ```shell
   git worktree remove ../v1.0.0-worktree
   ```

Cette commande supprime le lien du worktree avec Git, et le r√©pertoire `v1.0.0-worktree` est supprim√© du disque.

### üßæ R√©sum√© des commandes :

```shell
# Cr√©er un nouveau worktree bas√© sur le tag v1.0.0
git worktree add ../v1.0.0-worktree v1.0.0

# Aller dans le r√©pertoire du worktree
cd ../v1.0.0-worktree

# Revenir au r√©pertoire principal une fois termin√©
cd ../mon_projet

# Supprimer le worktree
git worktree remove ../v1.0.0-worktree
```

###### Conclusion :

**`git worktree`** permet de cr√©er des r√©pertoires temporaires bas√©s sur des tags (ou des commits) pour explorer ou modifier des versions
sp√©cifiques du projet sans perturber le r√©pertoire de travail principal. Une fois le travail termin√©, le worktree peut
√™tre facilement supprim√© avec `git worktree remove` pour maintenir un environnement propre et √©viter d'encombrer votre
espace disque.

##### Conclusion

Avec Git, il est possible de naviguer entre diff√©rentes versions du projet en utilisant les identifiants de commit, et
de revenir facilement √† l'√©tat actuel. C'est comme consulter d'anciennes "sauvegardes" du projet sans perdre les
modifications r√©centes.

#####  

## üß™ Tests

M√™me si elle est aussi test√©e durant l‚Äô√©criture (notamment avec des tests unitaires et/ou d‚Äôint√©gration automatis√©s),
une application doit √™tre valid√©e avant de partir en production, pour cela, on utilise un
[protocole de test](./TestsFonctionnelsSucrerie.docx).

## Release

Le syst√®me de versioning peut aider dans cette √©tape, notamment au travers d‚Äôune plateforme comme
[github](https://github.com/) qui permet de faire
une [release](https://docs.github.com/en/repositories/releasing-projects-on-github/managing-releases-in-a-repository).

![release-cosmos.png](release-cosmos.png)

Dans tous les cas, un `tag` est bienvenue si pas n√©cessaire :

### √âtape 1 : Ajouter un tag localement

1. **Cr√©er un tag pour la release**  
   Par exemple, pour la premi√®re version `v1.0.0` :
   ```shell
   git tag -a v1.0.0 -m "Premi√®re release de mon projet"
   ```

    - `-a v1.0.0` : Cr√©e un tag annot√© appel√© `v1.0.0`.
    - `-m "message"` : Ajoute un message √† la cr√©ation du tag.

2. **V√©rifier les tags existants**  
   Pour voir si le tag a bien √©t√© cr√©√© :
   ```shell
   git tag
   ```

   Cette commande liste tous les tags disponibles dans le d√©p√¥t.

### √âtape 2 : Pousser le tag vers GitHub

1. **Pousser le tag sur le d√©pot distant** :
   ```shell
   git push origin v1.0.0
   ```

   Cette commande pousse le tag `v1.0.0` vers le d√©p√¥t distant.

2. **Pousser tous les tags d'un coup (optionnel)**  
   S‚Äôil y a plusieurs tags √† pousser, une commande peut le faire en une fois :
   ```shell
   git push --tags
   ```

   Cela va pousser tous les tags locaux qui n'ont pas encore √©t√© envoy√©s vers GitHub.

### √âtape 3 : V√©rifier sur GitHub

- Une fois le tag pouss√©, on peut le voir sur GitHub sous l'onglet **"Releases"** ou **"Tags"** dans le d√©p√¥t.

### R√©sum√© des commandes :

```shell
# Cr√©er un tag pour la premi√®re release
git tag -a v1.0.0 -m "Premi√®re release de mon projet"

# Pousser le tag vers GitHub
git push origin v1.0.0

# (Optionnel) Pousser tous les tags d'un coup
git push --tags
```

> Cela permet de marquer une version stable du projet et de la rendre accessible aux collaborateurs ou √† d'autres
> utilisateurs directement via GitHub.

### D√©ploiement

Il faut aussi penser au d√©ploiement via un [assistant d‚Äôinstallation](https://installforge.net/) si possible.

#### Suppression

Sans oublier la `d√©sinstallation` du logiciel (prise en charge par l‚Äôassistant √† priori)

## Conclusion

Le d√©veloppement d‚Äôapplication comporte plus que la *simple √©criture de code* et ces √©tapes doivent √™tre prises en
compte notamment durant la phase de planification afin d‚Äô√©viter d‚Äôavoir du retard...

![delai.jpg](delai.jpg)
